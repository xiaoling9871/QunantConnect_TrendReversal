# -*- coding: utf-8 -*-
"""trendReversal 2.0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SMoHcOSSGjT5qyQShShAOXRKsI69S0V0
"""

from AlgorithmImports import *
import time
from threading import Timer

class TrendReveral(QCAlgorithm):

    def Initialize(self):
        self.SetTimeZone("America/New_York")
        manuallySetStartDate = datetime(2024, 2, 20)
        self.SetStartDate(manuallySetStartDate.year, manuallySetStartDate.month, manuallySetStartDate.day)  # Start date for backtesting
        endDate = manuallySetStartDate + timedelta(days=5)
        self.SetEndDate(endDate.year, endDate.month, endDate.day)
        self.SetCash(29000)
        self.quantity = 100
        self.dayTrade = True
        self.stocks=['AAPL', 'ABNB','AMAT','AMD', 'AMZN','BA','BBY',
          'COIN', 'DELL','DIS', 'ETSY', 'FDX',
          'GOOGL','IBM', 'IWM','JPM','MCD',
          'MGM', 'MRNA','MRVL','MSFT','MU','NKE', 'NTAP','ORCL',
          'PANW',  'QCOM', 'QQQ','SBUX','SHOP','SMH','SNOW','SPY',
          'SQ', 'TOL', 'TSLA', 'TTWO','TXN', 'UBER', 'WYNN',
          'ZS']
#       backup 2/17/2024 list below
#        self.stocks=['AAPL', 'ABNB','ABT','ADBE','ADM', 'AEE','AEP','AFRM','AIG', 'ALB','AMD', 'AMZN','AXP','BA', 'BAC', 'CHK',
#          'BIDU','COIN', 'COP','CRM','CVNA', 'DASH','DDOG', 'DIS', 'DKNG', 'DOCU','ETSY','EXPE', 'FDX',
#          'GILD','GM', 'GOOGL', 'H','IBM', 'IWM','INTC', 'JPM', 'KMX', 'KO', 'KR','KRE','L',
#          'MAR','MBLY', 'MCD','MGM', 'MMM','MRNA', 'MRVL','MU','NDAQ','NKE', 'ON','OXY',
#          'PEP',  'PYPL', 'QCOM', 'RCL','RBLX', 'RMBS','ROKU', 'RTX','SBUX','SHOP', 'SLB', 'SNOW','SPY','SPOT','QQQ',
#          'SQ', 'TGT', 'TOL', 'TSLA', 'TTWO','TXN', 'UAL', 'UBER', 'UPS','UPST', 'V','W', 'WDAY','WMT', 'WYNN', 'XBI',
#           'XOM', 'XOP', 'YUM','Z','NET','ENPH','TWLO','CSCO','AMAT','CROX','PANW']

        self.numDaysDown = 2
        self.priceDropThreshold = 0.5

        self.numDayDownInsideday = 2 # 2 days down, 3rd day is inside day

        self.dailyLow = dict()
        self.availableStocks = dict()
        self.availableStocksInsideday = dict()

        self.activePositions = dict()
        self.targetOrderIDs = dict()
        self.stopLossOrderIDs = dict()
        self.remainingQuantity = dict()
        self.inUse = dict() #stock: ifinuse
        self.desiredResolution = Resolution.Second

        self.RebuildTargetOrderIDs()

        self.Schedule.On(self.DateRules.EveryDay(),
                         self.TimeRules.At(9, 30),
                         self.CheckIfTradingDay)

        self.Schedule.On(self.DateRules.EveryDay(),
                         self.TimeRules.At(9, 30),
                         self.RebuildTargetOrderIDs)

        self.Debug(self.Portfolio.values())


    def CheckIfTradingDay(self):
        if self.Time.weekday() < 5:
            self.DaysDown(self.numDaysDown, self.numDayDownInsideday)
        else:
            return

    def OnData(self, data):
        if self.Time.minute == 0 and self.Time.second==0:
            for security in self.Portfolio.Values:
                if security.Invested:
                    self.Debug(f"Stock = {security}, Market Value = {security.HoldingsValue}")
        for stock in self.availableStocks.keys():
            if len(self.activePositions) < 5 and stock in data :
                currentPrice = data[stock].Price
                previousDayOrDaysLow = self.availableStocks[stock][0]
                previousDayOrDaysHigh = self.availableStocks[stock][1]
                if currentPrice < self.dailyLow[stock]:
                    self.dailyLow[stock] = currentPrice
                todayLow = self.dailyLow[stock]
                if  self.Time.hour > 9 or (self.Time.hour == 9 and self.Time.minute > 58):
                    if (self.Time.hour == 9 and self.Time.minute == 58):
                        self.Debug("start trading after 9:45")
                    if ((todayLow < previousDayOrDaysLow - self.priceDropThreshold) and (currentPrice > previousDayOrDaysLow) and (stock not in self.activePositions)) \
                        or ((currentPrice > previousDayOrDaysHigh) and (stock not in self.activePositions)) :
                            # ticket = self.LimitOrder(stock, self.quantity, todayLow)
                            ticket = self.MarketOrder(stock, self.quantity)
                            if(str(stock) not in self.remainingQuantity):
                                self.remainingQuantity[str(stock)] = 0
                            self.remainingQuantity[str(stock)] = self.quantity
                            self.activePositions[stock] = ticket.AverageFillPrice
                            self.Debug(f"Buy order placed for {stock} at market price {ticket.AverageFillPrice}.")
                            # self.activePositions[stock] = todayLow
                            # self.Debug(f"Buy order placed for {stock} at limit price {todayLow}.")

    def RebuildTargetOrderIDs(self):
        self.targetOrderIDs.clear()
        limitSellOrders = self.Transactions.GetOrderTickets(lambda orderTicket: orderTicket.Tag == "TargetSellOrder")
        for orderTicket in limitSellOrders:
            stock = str(orderTicket.Symbol)
            if stock not in self.targetOrderIDs:
                self.targetOrderIDs[str(stock)] = []
            self.targetOrderIDs[str(stock)].append(orderTicket.OrderId)
        self.Debug(f"The previous targetOrderIds are: {self.targetOrderIDs}")

    def DaysDown(self, numDaysDown, numDayDownInsideday):
        self.availableStocks = dict()
        for s in self.stocks:
            stock = self.AddEquity(s, Resolution.Daily).Symbol
            history = self.History(stock, 5, Resolution.Daily)
            historyList = list(history)
            if historyList == []:
                self.Debug(f"No data for stock {s}, please delete it from candidate list.")
                self.Debug("Deleting it from today's available stock list")
                self.availableStocks.pop(s)
                self.Debug("Delete complete.")
                continue
            closes = history['close']
            # rdr candidates
            if all(closes.iloc[i- numDaysDown -1] > closes.iloc[i - numDaysDown] for i in range(numDaysDown)):
                self.availableStocks[s] = [history['low'].iloc[-1],history['high'].iloc[-1]]
                self.dailyLow[s] = float('inf')

            #inside day candidates
            if all(closes.iloc[i- numDayDownInsideday -2] > closes.iloc[i - numDayDownInsideday -1] for i in range(numDayDownInsideday)):
                if (history['low'].iloc[-1] > history['low'].iloc[-2] and history['high'].iloc[-1] < history['high'].iloc[-2]):
                    preLow = float('inf')
                    for i in range(numDayDownInsideday + 2):
                        preLow = min(history['low'].iloc[-i - 1], preLow)
                    preHigh = history['high'].iloc[-1]
                    self.availableStocksInsideday[s] = [preLow, preHigh]
                    self.dailyLow[s] = float('inf')
            self.AddEquity(s, self.desiredResolution)

        self.Debug(f"For date {self.Time}, stocks {numDaysDown} days consecutive decreasing: [stock: [yesterday's low, yesterday's high]")
        for key, val in self.availableStocks.items():
            self.Debug(f"{key}:{val}")

        self.Debug(f"For date {self.Time}, stocks {numDayDownInsideday} days consecutive decreasing followed by inside-day: [stock: [previous days' low, previous days' high]")
        for key, val in self.availableStocksInsideday.items():
            self.Debug(f"{key}:{val}")

        self.availableStocks.update(self.availableStocksInsideday)

    def SetExitOrders(self, stock, entryPrice):
        stopLossPrice = self.dailyLow[stock.Value]
        targetPrices = [
            entryPrice + (entryPrice - stopLossPrice),
            entryPrice + 2 * (entryPrice - stopLossPrice),
            entryPrice + 3 * (entryPrice - stopLossPrice)
        ]
        targetPct = [int(0.3 * self.quantity), int(0.3 * self.quantity), int(0.4 * self.quantity)]

        self.targetOrderIDs[str(stock)] = []
        for i in range(len(targetPrices)):
            targetQuantity = -targetPct[i]
            targetPrice = targetPrices[i]
            orderTicket = self.LimitOrder(stock, targetQuantity, targetPrice, tag="TargetSellOrder")
            self.targetOrderIDs[str(stock)].append(orderTicket.OrderId)
            self.Debug(f"Setting limit sell order for {stock} at {targetPrice} for {targetQuantity} shares.")
        # self.Debug(f"the targetorderids are: {self.targetOrderIDs}")

        stopLossQuantity = -self.quantity
        stopLossOrderTicket = self.StopMarketOrder(stock, stopLossQuantity, stopLossPrice)
        self.stopLossOrderIDs[str(stock)] = stopLossOrderTicket.OrderId
        self.Debug(f"Setting stop-loss order for {stock} at {stopLossPrice} for {stopLossQuantity} shares.")

    def OnOrderEvent(self, orderEvent):
        order = self.Transactions.GetOrderById(orderEvent.OrderId)
        if orderEvent.Status == OrderStatus.Filled:
            stock = orderEvent.Symbol
            if order.Direction == OrderDirection.Buy:
                self.Debug(f"Successfully bought {order.Symbol} at {orderEvent.FillPrice}.")
                self.SetExitOrders(orderEvent.Symbol, orderEvent.FillPrice)

            elif order.Direction == OrderDirection.Sell:
                if self.IsTargetSellOrder(orderEvent.OrderId):
                    soldQuantity = -orderEvent.FillQuantity
                    self.remainingQuantity[str(stock)] = self.remainingQuantity[str(stock)]- soldQuantity
                    self.RemoveTargetSellOrderId(stock, orderEvent.OrderId)
                    self.Debug(f"Successfully sell {soldQuantity} shares {order.Symbol} at {orderEvent.FillPrice}.")
                    if self.remainingQuantity[str(stock)] >= 0:
                        self.AdjustStopLossOrder(stock, self.remainingQuantity[str(stock)])
                else:
                    self.Debug(f"Triger stop loss for {order.Symbol}, cancel all limit sell at target price")
                    self.CancelTargetSellOrders(stock)
                    self.Debug(f"Position closed for {stock}.")

    def IsTargetSellOrder(self, orderId):
        # Determine if the filled order is a target limit sell order
        for stock, orderIds in self.targetOrderIDs.items():
            if orderId in orderIds:
                return True
        return False

    def AdjustStopLossOrder(self, stock, remainingQuantity):
        if str(stock) not in self.inUse:
            self.inUse[str(stock)] = False
        # while self.inUse[str(stock)] == True:
        #     time.sleep(3)
        # Cancel the existing stop-loss order
        self.inUse[str(stock)] = True
        self.Transactions.CancelOrder(self.stopLossOrderIDs.get(str(stock)))
        self.Debug(f"Cancelled previous stop-loss order")
        if remainingQuantity != 0:
            # Place a new stop-loss order with the adjusted quantity
            self.Debug(f"Making new stop-loss order")
            stopLossPrice = float(self.dailyLow[stock.Value] )
            self.stopLossOrderIDs[str(stock)] = self.StopMarketOrder(stock, -remainingQuantity, stopLossPrice).OrderId
            self.Debug(f"Adjusted stop-loss order for {stock} at {stopLossPrice} for {-remainingQuantity} shares.")
        self.inUse[str(stock)] = False

    def CancelTargetSellOrders(self, stock):
        # Cancel all target sell orders for the stock
        for orderId in self.targetOrderIDs.get(str(stock), []):
            self.Transactions.CancelOrder(orderId)
        self.targetOrderIDs[str(stock)] = []
        self.Debug(f"Cancelling all target sell orders for stock {stock}.")

    def RemoveTargetSellOrderId(self, stock, orderId):
        if stock in self.targetOrderIDs and orderId in self.targetOrderIDs[str(stock)]:
            self.targetOrderIDs[str(stock)].remove(orderId)
            # self.Debug(f"Removed filled order ID {orderId} for stock {stock}.")

    def OnBrokerageDisconnect(self):
        self.Debug("Brokerage connection lost")
    def OnBrokerageReconnect(self):
        self.Debug("Brokerage connection restored")
    def OnBrokerageMessage(self, message_event: BrokerageMessageEvent):
        self.Debug(f"Brokerage message received: {message_event.Message}")